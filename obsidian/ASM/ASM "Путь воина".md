
----
# Представление каждой системы счисления в языке ассемблера

| 2-ичная система                                                                     | 8-ричная система                                                                  | 10-чная система                                                                     | 16-ричная система                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. Запись на языке ассемблера помечается индексом **b** на конце (пример,**1010b**) | 1. Запись на языке ассемблера помечается индексом **q** на конце (пример,**23q**) | 1. Запись на языке ассемблера помечается индексом **d** на конце (пример,**1234d**) | 1. Запись на языке ассемблера записывается вначале **0x** или **$0** в конце помечается индексом **h** <br>(пример,**0x01234**,**0$01234**,**01234h**)<br>2.Если первая цифра шестнадцатеричного числа<br>символ **A-F**, то перед таким числом нужно обязательно написать **0**,<br>чтобы компилятор понял, что перед ним число, а не идентификатор,<br>(пример, **ODEADh**).<br> |



----
#  Интересные факты и Значимые слова

1.  Слово **«bit» — это сокращение от «binary digit» — двоичная цифра.**
2. Бит может принимать два значения — 0 и 1 — ложь или истина, выключено или включено.
3. Двоичное число содержит столько битов, сколько двоичных цифр в его за­писи, поэтому диапазон допустимых значений выводится из количества раз­рядов (цифр), отведенных для числа.
4. Двоичное число содержит столько битов, сколько двоичных цифр в его за­писи, поэтому диапазон допустимых значений выводится из количества раз­рядов (цифр), отведенных для числа. Возьмем положительное целое двоичное число, состоящее из четырех битов: оно может выражать $2^4$ или шестнадцать различных значений. Возьмем положительное целое двоичное число, состоящее из четырех битов: оно может выражать $2^4$ или шестнадцать различных значений.
5. Биты (разряды) двоичного числа нумеруются справа налево, от наименее зна­чимого до наиболее значимого. Нумерация начинается с 0. Самый правый бит числа — это бит с номером 0 (первый бит). Этот бит называется **LSB -битом (Least Significant Bit — наименее значимый бит)**. Подобно этому самый левый бит называется **MSB-битом (Most Significant Bit — наиболее значимый бит)**.
6. Большие группы битов называются **словом (word)** или **двойным словом (dword — double word)**. Относительно PC -совместимых компьютеров мы можем сказать следующее:
			**1 байт = 8 бит
			1 слово (word) = 2 байта = 16 бит
			1 двойное слово (dword) = 4 байта = 32 бит**
	Один байт — это наименьшее количество данных, которое может быть про­
	читано из памяти или записано в нее, поэтому каждый байт памяти имеет
	индивидуальный адрес.

7. Представление Бита,1 байта, слова и двойного слова в компьютере и ASM![[Pasted image 20240922233913.png]]

8. В языках программирования высокого уровня есть специальные типы дан­ных, позволяющие хранить символы и строки. В языке ассемблера таких типов данных нет. Вместо них для представления одного символа использу­ ется байт, а для представления строки — группа последовательных байтов.
9. ASCII-таблица по приколу![[Pasted image 20240922234809.png]]

10. Собственно говоря, язык ассемблера — это всего лишь ориентированная на человека форма записи инструкций процессора (которые называются также машинным языком), а сам ассемблер — это программа, переводящая симво­ лические имена команд в машинные коды.
11. Концепция компьютера EDVAC, разработанная американским ученым венгерского происхождения Джоном фон Нейманом, основывалась
	на следующих принципах:
	*Компьютер должен состоять из следующих модулей: управляющий блок
(контроллер), арифметический блок, память, блоки ввода/вывода.
	Строение компьютера не должно зависеть от решаемой задачи (это как
раз относится к ENIAC ), программа должна храниться в памяти.
	Инструкции и их операнды (то есть данные) должны также храниться
в той же памяти (гарвардская концепция компьютеров, основанная на
концепции фон Неймана, предполагала отдельную память для про­
граммы и данных).
	Память делится на ячейки одинакового размера, порядковый номер
ячейки считается ее адресом (1 ячейка эквивалентна 1 байту).
	Программа состоит из серии элементарных инструкций, которые обыч­
но не содержат значения операнда (указывается только его адрес),
поэтому программа не зависит от обрабатываемых данных (это уже
прототип переменных). Инструкции выполняются одна за другой, в
том порядке, в котором они находятся в памяти (к слову, современные
микропроцессоры позволяют параллельное выполнение нескольких
инструкций).
	Для изменения порядка выполнения инструкций используются инструк­
ции условного или безусловного (jump) перехода.
	 Инструкции и данные (то есть операнды, результаты или адреса) пред­
ставляются в виде двоичных сигналов и в двоичной системе счисле­
ния.
12. Поговорим о внутреннем строении процессора. **Процессор** — это кремниевая
плата или «подложка» с логическими цепями, состоящими из транзисторов,
скрытая в пластмассовом корпусе, снабженном контактными ножками (вы­
водами, pin). Большинство ножек процессора подключено к шинам — шине
адреса, шине данных и шине управления, связывающим чип процессора с
остальной частью компьютера. Остальные ножки служат для подачи питания
на сам чип. Каждая шина состоит из группы проводников, которые выполняют
определенную функцию.
13. Это означает, что один проводник шины компьютера может «нести» один
бит. Значение этого бита (1 или 0) определяется уровнем напряжения в
проводнике. Значит, процессор с одной 16-разрядной шиной и одной 8-раз-
рядной должен иметь 24 (16 и 8) ножки, соединенные с различными прово­
дниками. Например, при передаче числа 27 (00011011 в двоичной системе)
по 8-разрядной шине проводник, по которому передается самый правый бит
(L S B ), покажет логический уровень 1, следующий провод также покажет 1,
следующий — 0 и т.д.
14. **Контроллер** управляет получение инструкций из памяти и их декодированием.
Контроллер не обрабатывает инструкцию: после декодирования он про­сто передает ее по внутренней шине управления к другим модулям, которые выполняют необходимое действие.
15. **Арифметико-логическое устройство (АЛУ)** выполняет арифметические и ло­гические действия над данными. Для более простых процессоров достаточно
АЛУ, умеющего выполнять операции отрицания и сложения, поскольку другие
арифметические действия (вычитание, умножение и целочисленное деление)
могут быть сведены к этим операциям.
	Другая, логическая, часть АЛУ выполняет основные логические действия
над данными, например, логическое сложение и умножение (ИЛИ, И), а
также исключительное ИЛИ. Еще одна функция АЛУ, которую выполняет
**устройство циклического сдвига**(barrel-shifter),заключается в сдвиге битов в право или лево.
16. Для выполнения процессором инструкции необходимо намного меньше вре­
мени, чем для чтения этой инструкции из памяти. Чтобы сократить время
ожидания памяти, процессор снабжен временным хранилищем инструкций и данных — **регистрами**. Размер регистра — несколько байтов, но зато доступ
к регистрам осуществляется почти мгновенно.
 17. Среди регистров обязательно должны присутствовать следующие группы:
**регистры общего назначения, регистры состояния и счетчики**.

**Регистры обще­го назначения** содержат рабочие данные, полученные из памяти. 

**Регистры состояния** содержат текущее состояние процессора (или состояние АЛУ).
Последняя группа — это **счетчики**. Согласно теории фон Неймана, должен
быть хотя бы один регистр из этой группы — счетчик команд, содержащий
адрес следующей инструкции. 
18.  ЕАХ ,ЕВХ , ЕСХ и EDX (Аккумулятор, База, Счетчик и Данные). Кроме названий, они больше ничем другим не отличаются друг от друга
19. 
![[Pasted image 20240923023936.png]]
20. **Регистры общего назначения**   
    Процессор 80386 обратно совместим с процессором 80286, регистры которого
16-разрядные. Как же 80386 может выполнять команды, предназначенные
для регистров меньшего размера? Регистр ЕАХ может быть разделен на две
части — 16-разрядный регистр АХ (который также присутствует в 80286) и
верхние 16 битов, которые никак не называются. В свою очередь, регистр
А Х может быть разделен (не только в 80386, но и в 80286) на два 8-битных
регистра — АН и AL.
Если мы заносим в регистр ЕАХ значение 0x12345678, то регистр АХ будет
содержать значение 0x5678 (0x56 в АН и 0x78 в AL ), а значение 0x1234 будет
помещено в верхнюю часть регистра ЕАХ .
«Младшие» регистры других регистров общего назначения называются по
такому же принципу: ЕВХ содержит ВХ , который, в свою очередь, содержит
ВН и BL и т.д.
21. **Индексные регистры** 
    К регистрам общего назначения иногда относят и индексные регистры про­
цессора 80386 — ESI, EDI и EBP (или SI, DI и ВР для 16-разрядных действий).
Обычно эти регистры используются для адресации памяти: обращения к
массивам, индексирования и т.д. Отсюда их имена: индекс источника (Source
Index), индекс приемника (Destination Index), указатель базы (Base Pointer).
22. Но хранить в них только адреса совсем необязательно: регистры ESI, EDI и
EBP могут содержать произвольные данные. Эти регистры программно до­
ступны, то есть их содержание может быть изменено программистом. Другие
регистры лучше «руками не трогать».
У регистров ESI, EDI и EBP существуют только в 16-разрядная и 32-разряд-
ная версии. 
23. **Сегментные регистры**
Эту группу регистров можно отнести к регистрам состояния. Регистры из этой
группы используются при вычислении реального адреса (адреса, который
будет передан на шину адреса). Процесс вычисления реального адреса зави­
сит от режима процессора (реальный или защищенный) и будет рассмотрен
в следующих главах. Сегментные регистры только 16-разрядные, такие же,
как в 80286.
Названия этих регистров соответствуют выполняемым функциям: CS (Code
Segment, сегмент кода) вместе с EIP (IP ) определяют адрес памяти, откуда
нужно прочитать следующую инструкцию; аналогично регистр SS (Stack
Segment, сегмент стека) в паре с ESP (SS:SP) указывают на вершину стека.
Сегментные регистры DS, ES, FS, и GS (Data, Extra, F и G сегменты) исполь­
зуются для адресации данных в памяти.
24. **Регистры состояния и управления**
Регистр ESP (SP) — это указатель памяти, который указывает на вершину
стека (х86-совместимые процессоры не имеют аппаратного стека). О стеке мы
поговорим в следующих главах. Также программно не может быть изменен
регистр EIP (IP , Instruction Pointer) — указатель команд. Этот регистр ука­
зывает на инструкцию, которая будет выполнена следующей. Значение этого
регистра изменяется непосредственно контроллером процессора согласно
инструкциям, полученным из памяти.
Нам осталось рассмотреть только регистр флагов (иногда его называют реги­
стром признаков) — EFLAGS. Он состоит из одноразрядных флагов, отобра­
жающих в основном текущее состояние арифметико-логического устройства.
В наших программах мы будем использовать все 32 флага, а пока рассмотрим
только самые важные из них:
	Признак нуля ZF (Zero Flag) — 1, если результат предыдущей операции
равен нулю.
	Признак знака SF (Sign Flag) — 1 если результат предыдущей операции
отрицательный.
	Признак переполнения OF (Overflow Flag) — 1, если при выполнении
предыдущей операции произошло переполнение (overflow), то есть
результат операции больше, чем зарезервированная для него память.
	Признак переноса CF (Carry Flag) — 1, если бит был «перенесен» и стал
битом более высокого порядка (об этом мы поговорим в четвертой главе,
когда будем рассматривать арифметические операции).
Признак прерывания IF (Interrupt Flag) — 1, если прерывания процес­сора разрешены.
	Признак направления DF (Direction Flag) — используется для обработки
строк, мы рассмотрим подробнее этот регистр в шестой главе.
25. Прерывания могут быть программными и аппаратными.
Аппаратные прерывания происходят по запросу периферийных устройств и
называются IR Q (Interrupt Requests). Архитектура шины ISA ограничивает
их число до 16 (IRQ 0 — IRQ15).
К аппаратным прерываниям относятся также специальные прерывания,
которые генерирует сам процессор. Такие прерывания используются для
обработки «исключительных ситуаций» — неверный операнд, неизвестная
команда, переполнение и другие непредвиденные операции, когда процессор
сбит с толку и не знает, что делать. Эти прерывания имеют свои обозначения
и никак не относятся к зарезервированным для периферии прерываниям IRQ0-IRQ15.
Все аппаратные прерывания можно разделить на две группы: прерывания,
которые можно игнорировать («замаскировать») и те, которые игнорировать
нельзя. Первые называются маскируемыми (maskable), а вторые — немаски­
руемыми (non-maskable). Аппаратные прерывания могут быть отключены
путем установки флага IF регистра признаков в 0. Единственное прерывание,
которое отключить нельзя — это NMI, немаскируемое прерывание, генери­
рующееся при сбое памяти, сбое в питании процессора и подобных форс­
мажорных обстоятельствах.
Программные прерывания генерируются с помощью специальной команды
в теле программы, то есть их порождает программист. Обычно программные
прерывания используются для «общения» вашей программы с операционной
системой.
26. Существует две основные архитектуры процессоров. Первая называется **RISC**
(Reduced Instruction Set Computer) — компьютер с уменьшенным набором ко­
манд. Архитектура **RISC** названа в честь первого компьютера с уменьшенным
набором команд — RISC I. Идея этой архитектуры основывается на том, что
процессор большую часть времени тратит на выполнение ограниченного числа
инструкций (например, переходов или команд присваивания), а остальные
команды используются редко.
Разработчики RISC -архитектуры создали «облегченный» процессор. Благодаря
упрощенной внутренней логике (меньшему числу команд, менее сложным
логическим контурам), значительно сократилось время выполнения отдельных
команд и увеличилась общая производительность. Архитектура RISC подобна
«архитектуре общения» с собакой — она знает всего несколько команд, но
выполняет их очень быстро.
Вторая архитектура имеет сложную систему команд, она называется **CISC**
(Complex Instruction Set Computer) — компьютер со сложной системой ко­
манд. Архитектура CISC подразумевает использование сложных инструкций,
которые можно разделить на более простые. Все х86-совместимые процессоры
принадлежат к архитектуре CISC.

----
# Команды и Операнды

1. Данные, которые обрабатываются командами, называются **операндами**. Опе­ранды в языке ассемблера записываются непосредственно после команды; если их несколько, то через запятую. Одни команды вообще не имеют никаких операндов, другие имеют один или два операнда.
2. ![[Pasted image 20240925000618.png]]
3. Мы уже знаем, что адрес, как и сама команда,это число. Чтобы запоминать адреса всех «переменных», используемых в программе, этим адресам присваивают символические обозначения, которые называются **переменными** (иногда их также называют указателями).
4. При использовании косвенного операнда адрес в памяти, по которому
ходится нужное значение, записывается в квадратных скобках, [адрес]. Еще,
мы используем указатель, то есть символическое представление адреса, на­
пример, [ESI], то в листинге машинного кода мы увидим, что указатель был
заменен реальным значением адреса. Можно также указать точный адрес
памяти, например, [0x594F].В нашем случае, чтобы получить доступ ко второму элементу массива, нужно записать косвенный операнд [ESI + 1].
5. Имеются даже более сложные типы адресации: [адрес + ЕВХ + 4]. В этом
случае процессор складывает адрес, значение 4 и значение, содержащееся в
регистре ЕВХ. Результат этого выражения называется эффективным адресом
(Е А , Effective Address) и используется в качестве адреса, по которому факти­
чески находится операнд (мы пока не рассматриваем сегментные регистры).
6.  Сменить регистр по умолчанию можно так:
```Assembly
	ES:[ESI]
```
Некоторые ассемблеры требуют указания регистра внутри скобок:
```Assembly
	[ES:ESI]
```

7.  Общий формат команды языка ассемблера такой:
	```Assembly
	имя_команды [подсказка] операнды
	```
8. ![[Pasted image 20240925004114.png]]

## КОМАНДА MOV

9.  ## Команда **MOV**, хоть название ее и происходит от слова «move» (переме­щать), на самом деле не перемещает, а копирует значение из источника вприемник:
```Assembly
	MOV приемник, источник
```
![[Pasted image 20240925005015.png]]
Процессоры семейства х86 позволяют использовать в командах только один
косвенный аргумент. Следующая команда копирования значения, находя­
щегося по адресу num ber_one, в область памяти с адресом num ber_two,
недопустима:
```Assembly
mov [number_two],[number_one] ;НЕПРАВИЛЬНО!!!
```
Чтобы скопировать значение из одной обл. памяти в другую, нужно , чтобы перед ним был промежуточный регистр:
```Assembly
mov AX,[number_one] ;ПРАВИЛЬНО!!! 
mov [number_two],AX ;ПРАВИЛЬНО!!!
```
10. Оба операнда команды MOV должны быть одного размера.
	mov AX,BL

```Assembly
mov AX,BL ;НЕПРАВИЛЬНО! - Операнды разных размеров.
```
Для копирования значения BL (EBX->пустая часть и BX->BH и BL)в регистр АХ мы должны «расширить диапа­зон», то есть скопировать весь ВХ в АХ , а затем загрузить 0 в АХ :
```Assembly
mov AX, BX         ;загружаем ВХ в АХ
				   ;"сбрасываем" верхнюю часть
				   	   
mov ah, 0          ;АХ - записываем в нее 0
```
 
Можно поступить и наоборот: сначала сбросить весь АХ, а затем загрузить
BL в младшую часть АХ(AL):
```Assembly
mov AX, 0           ;АН = О, AL = О
mov AL,BL           ;заносим в AL значение BL
```

11. ![[Pasted image 20240925015323.png]]

12. Пример того, что происходит при трансляции и дебаге кода языка ассемблера в машинный:
![[Pasted image 20240925022910.png]]
![[Pasted image 20240925022810.png]]![[Pasted image 20240925022821.png]]

##  КОМАНДЫ ADD И SUB

13.
 Команда **ADD** требует двух операндов, как и команда MOV:
 ```Assembly
ADD O1, O2 
```
Команда ADD складывает оба операнда и записывает результат в O1, предыдущее значение которого теряется. Точно так же работает команда вычитания SUB:
 ```Assembly
SUB O1, O2 
```

![[Pasted image 20240925024450.png]]
