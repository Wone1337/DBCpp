# Используемое руководство "Рудольф Марек - Ассемблер на примерах , базовый курс"
----
----

# Представление каждой системы счисления в языке ассемблера

| 2-ичная система                                                                     | 8-ричная система                                                                  | 10-чная система                                                                     | 16-ричная система                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. Запись на языке ассемблера помечается индексом **b** на конце (пример,**1010b**) | 1. Запись на языке ассемблера помечается индексом **q** на конце (пример,**23q**) | 1. Запись на языке ассемблера помечается индексом **d** на конце (пример,**1234d**) | 1. Запись на языке ассемблера записывается вначале **0x** или **$0** в конце помечается индексом **h** <br>(пример,**0x01234**,**0$01234**,**01234h**)<br>2.Если первая цифра шестнадцатеричного числа<br>символ **A-F**, то перед таким числом нужно обязательно написать **0**,<br>чтобы компилятор понял, что перед ним число, а не идентификатор,<br>(пример, **ODEADh**).<br> |



----
#  Интересные факты и Значимые слова

1.  Слово **«bit» — это сокращение от «binary digit» — двоичная цифра.**
2. Бит может принимать два значения — 0 и 1 — ложь или истина, выключено или включено.
3. Двоичное число содержит столько битов, сколько двоичных цифр в его за­писи, поэтому диапазон допустимых значений выводится из количества раз­рядов (цифр), отведенных для числа.
4. Двоичное число содержит столько битов, сколько двоичных цифр в его за­писи, поэтому диапазон допустимых значений выводится из количества раз­рядов (цифр), отведенных для числа. Возьмем положительное целое двоичное число, состоящее из четырех битов: оно может выражать $2^4$ или шестнадцать различных значений. Возьмем положительное целое двоичное число, состоящее из четырех битов: оно может выражать $2^4$ или шестнадцать различных значений.
5. Биты (разряды) двоичного числа нумеруются справа налево, от наименее зна­чимого до наиболее значимого. Нумерация начинается с 0. Самый правый бит числа — это бит с номером 0 (первый бит). Этот бит называется **LSB -битом (Least Significant Bit — наименее значимый бит)**. Подобно этому самый левый бит называется **MSB-битом (Most Significant Bit — наиболее значимый бит)**.
6. Большие группы битов называются **словом (word)** или **двойным словом (dword — double word)**. Относительно PC -совместимых компьютеров мы можем сказать следующее:
			**1 байт = 8 бит
			1 слово (word) = 2 байта = 16 бит
			1 двойное слово (dword) = 4 байта = 32 бит**
	Один байт — это наименьшее количество данных, которое может быть про­
	читано из памяти или записано в нее, поэтому каждый байт памяти имеет
	индивидуальный адрес.

7. Представление Бита,1 байта, слова и двойного слова в компьютере и ASM![[Pasted image 20240922233913.png]]

8. В языках программирования высокого уровня есть специальные типы дан­ных, позволяющие хранить символы и строки. В языке ассемблера таких типов данных нет. Вместо них для представления одного символа использу­ ется байт, а для представления строки — группа последовательных байтов.
9. ASCII-таблица по приколу![[Pasted image 20240922234809.png]]

10. Собственно говоря, язык ассемблера — это всего лишь ориентированная на человека форма записи инструкций процессора (которые называются также машинным языком), а сам ассемблер — это программа, переводящая симво­ лические имена команд в машинные коды.
11. Концепция компьютера EDVAC, разработанная американским ученым венгерского происхождения Джоном фон Нейманом, основывалась
	на следующих принципах:
	*Компьютер должен состоять из следующих модулей: управляющий блок
(контроллер), арифметический блок, память, блоки ввода/вывода.
	Строение компьютера не должно зависеть от решаемой задачи (это как
раз относится к ENIAC ), программа должна храниться в памяти.
	Инструкции и их операнды (то есть данные) должны также храниться
в той же памяти (гарвардская концепция компьютеров, основанная на
концепции фон Неймана, предполагала отдельную память для про­
граммы и данных).
	Память делится на ячейки одинакового размера, порядковый номер
ячейки считается ее адресом (1 ячейка эквивалентна 1 байту).
	Программа состоит из серии элементарных инструкций, которые обыч­
но не содержат значения операнда (указывается только его адрес),
поэтому программа не зависит от обрабатываемых данных (это уже
прототип переменных). Инструкции выполняются одна за другой, в
том порядке, в котором они находятся в памяти (к слову, современные
микропроцессоры позволяют параллельное выполнение нескольких
инструкций).
	Для изменения порядка выполнения инструкций используются инструк­
ции условного или безусловного (jump) перехода.
	 Инструкции и данные (то есть операнды, результаты или адреса) пред­
ставляются в виде двоичных сигналов и в двоичной системе счисле­
ния.
12. Поговорим о внутреннем строении процессора. **Процессор** — это кремниевая
плата или «подложка» с логическими цепями, состоящими из транзисторов,
скрытая в пластмассовом корпусе, снабженном контактными ножками (вы­
водами, pin). Большинство ножек процессора подключено к шинам — шине
адреса, шине данных и шине управления, связывающим чип процессора с
остальной частью компьютера. Остальные ножки служат для подачи питания
на сам чип. Каждая шина состоит из группы проводников, которые выполняют
определенную функцию.
13. Это означает, что один проводник шины компьютера может «нести» один
бит. Значение этого бита (1 или 0) определяется уровнем напряжения в
проводнике. Значит, процессор с одной 16-разрядной шиной и одной 8-раз-
рядной должен иметь 24 (16 и 8) ножки, соединенные с различными прово­
дниками. Например, при передаче числа 27 (00011011 в двоичной системе)
по 8-разрядной шине проводник, по которому передается самый правый бит
(L S B ), покажет логический уровень 1, следующий провод также покажет 1,
следующий — 0 и т.д.
14. **Контроллер** управляет получение инструкций из памяти и их декодированием.
Контроллер не обрабатывает инструкцию: после декодирования он про­сто передает ее по внутренней шине управления к другим модулям, которые выполняют необходимое действие.
15. **Арифметико-логическое устройство (АЛУ)** выполняет арифметические и ло­гические действия над данными. Для более простых процессоров достаточно
АЛУ, умеющего выполнять операции отрицания и сложения, поскольку другие
арифметические действия (вычитание, умножение и целочисленное деление)
могут быть сведены к этим операциям.
	Другая, логическая, часть АЛУ выполняет основные логические действия
над данными, например, логическое сложение и умножение (ИЛИ, И), а
также исключительное ИЛИ. Еще одна функция АЛУ, которую выполняет
**устройство циклического сдвига**(barrel-shifter),заключается в сдвиге битов в право или лево.
16. Для выполнения процессором инструкции необходимо намного меньше вре­
мени, чем для чтения этой инструкции из памяти. Чтобы сократить время
ожидания памяти, процессор снабжен временным хранилищем инструкций и данных — **регистрами**. Размер регистра — несколько байтов, но зато доступ
к регистрам осуществляется почти мгновенно.
 17. Среди регистров обязательно должны присутствовать следующие группы:
**регистры общего назначения, регистры состояния и счетчики**.

**Регистры обще­го назначения** содержат рабочие данные, полученные из памяти. 

**Регистры состояния** содержат текущее состояние процессора (или состояние АЛУ).
Последняя группа — это **счетчики**. Согласно теории фон Неймана, должен
быть хотя бы один регистр из этой группы — счетчик команд, содержащий
адрес следующей инструкции. 
18.  ЕАХ ,ЕВХ , ЕСХ и EDX (Аккумулятор, База, Счетчик и Данные). Кроме названий, они больше ничем другим не отличаются друг от друга
19. 
![[Pasted image 20240923023936.png]]
20. **Регистры общего назначения**   
    Процессор 80386 обратно совместим с процессором 80286, регистры которого
16-разрядные. Как же 80386 может выполнять команды, предназначенные
для регистров меньшего размера? Регистр ЕАХ может быть разделен на две
части — 16-разрядный регистр АХ (который также присутствует в 80286) и
верхние 16 битов, которые никак не называются. В свою очередь, регистр
А Х может быть разделен (не только в 80386, но и в 80286) на два 8-битных
регистра — АН и AL.
Если мы заносим в регистр ЕАХ значение 0x12345678, то регистр АХ будет
содержать значение 0x5678 (0x56 в АН и 0x78 в AL ), а значение 0x1234 будет
помещено в верхнюю часть регистра ЕАХ .
«Младшие» регистры других регистров общего назначения называются по
такому же принципу: ЕВХ содержит ВХ , который, в свою очередь, содержит
ВН и BL и т.д.
21. **Индексные регистры** 
    К регистрам общего назначения иногда относят и индексные регистры про­
цессора 80386 — ESI, EDI и EBP (или SI, DI и ВР для 16-разрядных действий).
Обычно эти регистры используются для адресации памяти: обращения к
массивам, индексирования и т.д. Отсюда их имена: индекс источника (Source
Index), индекс приемника (Destination Index), указатель базы (Base Pointer).
22. Но хранить в них только адреса совсем необязательно: регистры ESI, EDI и
EBP могут содержать произвольные данные. Эти регистры программно до­
ступны, то есть их содержание может быть изменено программистом. Другие
регистры лучше «руками не трогать».
У регистров ESI, EDI и EBP существуют только в 16-разрядная и 32-разряд-
ная версии. 
23. **Сегментные регистры**
Эту группу регистров можно отнести к регистрам состояния. Регистры из этой
группы используются при вычислении реального адреса (адреса, который
будет передан на шину адреса). Процесс вычисления реального адреса зави­
сит от режима процессора (реальный или защищенный) и будет рассмотрен
в следующих главах. Сегментные регистры только 16-разрядные, такие же,
как в 80286.
Названия этих регистров соответствуют выполняемым функциям: CS (Code
Segment, сегмент кода) вместе с EIP (IP ) определяют адрес памяти, откуда
нужно прочитать следующую инструкцию; аналогично регистр SS (Stack
Segment, сегмент стека) в паре с ESP (SS:SP) указывают на вершину стека.
Сегментные регистры DS, ES, FS, и GS (Data, Extra, F и G сегменты) исполь­
зуются для адресации данных в памяти.
24. **Регистры состояния и управления**
Регистр ESP (SP) — это указатель памяти, который указывает на вершину
стека (х86-совместимые процессоры не имеют аппаратного стека). О стеке мы
поговорим в следующих главах. Также программно не может быть изменен
регистр EIP (IP , Instruction Pointer) — указатель команд. Этот регистр ука­
зывает на инструкцию, которая будет выполнена следующей. Значение этого
регистра изменяется непосредственно контроллером процессора согласно
инструкциям, полученным из памяти.
Нам осталось рассмотреть только регистр флагов (иногда его называют реги­
стром признаков) — EFLAGS. Он состоит из одноразрядных флагов, отобра­
жающих в основном текущее состояние арифметико-логического устройства.
В наших программах мы будем использовать все 32 флага, а пока рассмотрим
только самые важные из них:
	Признак нуля ZF (Zero Flag) — 1, если результат предыдущей операции
равен нулю.
	Признак знака SF (Sign Flag) — 1 если результат предыдущей операции
отрицательный.
	Признак переполнения OF (Overflow Flag) — 1, если при выполнении
предыдущей операции произошло переполнение (overflow), то есть
результат операции больше, чем зарезервированная для него память.
	Признак переноса CF (Carry Flag) — 1, если бит был «перенесен» и стал
битом более высокого порядка (об этом мы поговорим в четвертой главе,
когда будем рассматривать арифметические операции).
Признак прерывания IF (Interrupt Flag) — 1, если прерывания процес­сора разрешены.
	Признак направления DF (Direction Flag) — используется для обработки
строк, мы рассмотрим подробнее этот регистр в шестой главе.
25. Прерывания могут быть программными и аппаратными.
Аппаратные прерывания происходят по запросу периферийных устройств и
называются IR Q (Interrupt Requests). Архитектура шины ISA ограничивает
их число до 16 (IRQ 0 — IRQ15).
К аппаратным прерываниям относятся также специальные прерывания,
которые генерирует сам процессор. Такие прерывания используются для
обработки «исключительных ситуаций» — неверный операнд, неизвестная
команда, переполнение и другие непредвиденные операции, когда процессор
сбит с толку и не знает, что делать. Эти прерывания имеют свои обозначения
и никак не относятся к зарезервированным для периферии прерываниям IRQ0-IRQ15.
Все аппаратные прерывания можно разделить на две группы: прерывания,
которые можно игнорировать («замаскировать») и те, которые игнорировать
нельзя. Первые называются маскируемыми (maskable), а вторые — немаски­
руемыми (non-maskable). Аппаратные прерывания могут быть отключены
путем установки флага IF регистра признаков в 0. Единственное прерывание,
которое отключить нельзя — это NMI, немаскируемое прерывание, генери­
рующееся при сбое памяти, сбое в питании процессора и подобных форс­
мажорных обстоятельствах.
Программные прерывания генерируются с помощью специальной команды
в теле программы, то есть их порождает программист. Обычно программные
прерывания используются для «общения» вашей программы с операционной
системой.
26. Существует две основные архитектуры процессоров. Первая называется **RISC**
(Reduced Instruction Set Computer) — компьютер с уменьшенным набором ко­
манд. Архитектура **RISC** названа в честь первого компьютера с уменьшенным
набором команд — RISC I. Идея этой архитектуры основывается на том, что
процессор большую часть времени тратит на выполнение ограниченного числа
инструкций (например, переходов или команд присваивания), а остальные
команды используются редко.
Разработчики RISC -архитектуры создали «облегченный» процессор. Благодаря
упрощенной внутренней логике (меньшему числу команд, менее сложным
логическим контурам), значительно сократилось время выполнения отдельных
команд и увеличилась общая производительность. Архитектура RISC подобна
«архитектуре общения» с собакой — она знает всего несколько команд, но
выполняет их очень быстро.
Вторая архитектура имеет сложную систему команд, она называется **CISC**
(Complex Instruction Set Computer) — компьютер со сложной системой ко­
манд. Архитектура CISC подразумевает использование сложных инструкций,
которые можно разделить на более простые. Все х86-совместимые процессоры
принадлежат к архитектуре CISC.

----
# Команды и Операнды

1. Данные, которые обрабатываются командами, называются **операндами**. Опе­ранды в языке ассемблера записываются непосредственно после команды; если их несколько, то через запятую. Одни команды вообще не имеют никаких операндов, другие имеют один или два операнда.
2. ![[Pasted image 20240925000618.png]]
3. Мы уже знаем, что адрес, как и сама команда,это число. Чтобы запоминать адреса всех «переменных», используемых в программе, этим адресам присваивают символические обозначения, которые называются **переменными** (иногда их также называют указателями).
4. При использовании косвенного операнда адрес в памяти, по которому
ходится нужное значение, записывается в квадратных скобках, [адрес]. Еще,
мы используем указатель, то есть символическое представление адреса, на­
пример, [ESI], то в листинге машинного кода мы увидим, что указатель был
заменен реальным значением адреса. Можно также указать точный адрес
памяти, например, [0x594F].В нашем случае, чтобы получить доступ ко второму элементу массива, нужно записать косвенный операнд [ESI + 1].
5. Имеются даже более сложные типы адресации: [адрес + ЕВХ + 4]. В этом
случае процессор складывает адрес, значение 4 и значение, содержащееся в
регистре ЕВХ. Результат этого выражения называется эффективным адресом
(Е А , Effective Address) и используется в качестве адреса, по которому факти­
чески находится операнд (мы пока не рассматриваем сегментные регистры).
6.  Сменить регистр по умолчанию можно так:
```Assembly
	ES:[ESI]
```
Некоторые ассемблеры требуют указания регистра внутри скобок:
```Assembly
	[ES:ESI]
```

7.  Общий формат команды языка ассемблера такой:
	```Assembly
	имя_команды [подсказка] операнды
	```
8. ![[Pasted image 20240925004114.png]]

## КОМАНДА MOV

9.  ## Команда **MOV**, хоть название ее и происходит от слова «move» (переме­щать), на самом деле не перемещает, а копирует значение из источника вприемник:
```Assembly
	MOV приемник, источник
```
![[Pasted image 20240925005015.png]]
Процессоры семейства х86 позволяют использовать в командах только один
косвенный аргумент. Следующая команда копирования значения, находя­
щегося по адресу num ber_one, в область памяти с адресом num ber_two,
недопустима:
```Assembly
mov [number_two],[number_one] ;НЕПРАВИЛЬНО!!!
```
Чтобы скопировать значение из одной обл. памяти в другую, нужно , чтобы перед ним был промежуточный регистр:
```Assembly
mov AX,[number_one] ;ПРАВИЛЬНО!!! 
mov [number_two],AX ;ПРАВИЛЬНО!!!
```
10. Оба операнда команды MOV должны быть одного размера.
	mov AX,BL

```Assembly
mov AX,BL ;НЕПРАВИЛЬНО! - Операнды разных размеров.
```
Для копирования значения BL (EBX->пустая часть и BX->BH и BL)в регистр АХ мы должны «расширить диапа­зон», то есть скопировать весь ВХ в АХ , а затем загрузить 0 в АХ :
```Assembly
mov AX, BX         ;загружаем ВХ в АХ
				   ;"сбрасываем" верхнюю часть
				   	   
mov ah, 0          ;АХ - записываем в нее 0
```
 
Можно поступить и наоборот: сначала сбросить весь АХ, а затем загрузить
BL в младшую часть АХ(AL):
```Assembly
mov AX, 0           ;АН = О, AL = О
mov AL,BL           ;заносим в AL значение BL
```

11. ![[Pasted image 20240925015323.png]]

12. Пример того, что происходит при трансляции и дебаге кода языка ассемблера в машинный:
![[Pasted image 20240925022910.png]]
![[Pasted image 20240925022810.png]]![[Pasted image 20240925022821.png]]

##  КОМАНДЫ ADD И SUB,ADC и SBB

13. 
 Команда **ADD** требует двух операндов, как и команда MOV:
 ```Assembly
ADD O1, O2 
```
Команда ADD складывает оба операнда и записывает результат в O1, предыдущее значение которого теряется. Точно так же работает команда вычитания **SUB**:
 ```Assembly
SUB O1, O2 
```

![[Pasted image 20240925024450.png]]
 
 14. Случай ,при котором происходит переполнение в регистре и как оно решается:
     ![[Pasted image 20240926012145.png]]
	   ![[Pasted image 20240926012212.png]]
	
15. В контексте арифметических операций очень часто используются так называе­мые _пары регистров_. **Пара** — это два регистра, использующихся для хранения одного числа. Часто используется пара EDX :EAX(или DX:АХ ) — обычно при умножении. Регистр АХ хранит младшие 16 битов числа, a DX — старшие 16 битов. Таким способом даже древний 80286 может обрабатывать 32-разрядные числа, хотя у него нет ни одного 32-разрядного регистра.
Пример: пара DX :AX содержит значение OxFFFF (А Х = OxFFFF, D X = 0).
Добавим 8 к этой паре и запишем результат обратно в DX:АХ :
```Assembly
mov ах, Oxffff    ;AX = OxFFFF
mov dx, 0         ;DX = 0
add ах, 8         ;AX = AX + 8
adc dx, 0         ;добавляем 0 с переносом к DX
```
Первая команда ADD добавит 8 к регистру АХ . Полностью результат не по­
мещается в А Х , поэтому его старший бит переходит в CF. Вторая команда добавит к DX значение 0 и значение CF(который равен 1). После выполнения ADC флаг CF будет добавлен к DX (DX теперь равен 1,т.к 0 + 0 + CF(**1**)  ).
Результат сложения OxFFFF и 8 (0x10007) будет помещен в пару DX:AX
(DX=1, АХ=0007).

![[Pasted image 20240926014238.png]]


## КОМАНДЫ INC и DEC

16. Эти команды предназначены для инкрементирования и декрементирования.
Команда **INC** добавляет, a **DEC** вычитает единицу из единственного операнда.
Допустимые типы операнда — такие же, как у команд ADD и SUB, а формат
команд таков:
```Assembly
INC O1      ;O1 = O1 + 1
DEC O1      ;O1 = O1 - 1
```

>> **ВНИМАНИЕ!** Ни одна из этих инструкций не изменяет флаг CF. 


## Преобразование целых чисел в числа с отрицательным  знаком 


17. ![[Pasted image 20240926021852.png]]
    ![[Pasted image 20240926021932.png]]
    ![[Pasted image 20240926022010.png]]


## КОМАНДЫ NEG, CBW, CWD, СDQ, CWDE

18. Используя **NEG** , вы можете преобразовывать положительное целое число в отрицательное и наоборот. Инструкция NEG имеет только один операнд, который может быть регистром или адресом памяти. Размер операнда — лю­ бой: 8,16 или 32 бита.
	```Assembly
	NEG EAX       ;ИЗМЕНЯЕТ ЗНАЧЕНИЕ В РЕГИСТРЕ EAX(32 бита) НА + ИЛИ -
	
	NEG BL        ;ИЗМЕНЯЕТ ЗНАЧЕНИЕ В РЕГИСТРЕ BL(8 бит) НА + ИЛИ -
	
	NEG BYTE [number] ;ИЗМЕНЯЕТ ЗНАЧЕНИЕ В number(8 бит) по адресу на + или -
	
	```

19.  Команда **CBW** копирует седьмой (старший) бит регистра AL в регистр АН , рас­ширяя таким образом оригинальное значение регистра A L в значение со знаком регистра А Х (значение А Н становится равно 0x00 или OxFF = 11111111b, в за­ висимости от старшего бита AL).
 ![[Pasted image 20240926025032.png]]
 
 20. Команда **CWD** копирует старший бит АХ в регистр DX, расширяя таким об
разом оригинальное значение АХ в пару регистров со знаком DX:AX.
![[Pasted image 20240926025203.png]]

21. Команда **CDQ** копирует старший бит ЕАХ в регистр EDX, расширяя таким об­
разом оригинальное значение ЕАХ в пару регистров со знаком EDX:EAX.
![[Pasted image 20240926032354.png]]

22. Команда **CWDE** копирует старший бит АХ в верхнюю часть (старшую часть)
ЕАХ, расширяя таким образом оригинальное значение АХ в двойное слово
со знаком, которое будет помещено в регистр ЕАХ .
![[Pasted image 20240926031123.png]]

## КОМАНДЫ MUL,DIV,IMUL,IDIV

23. Команда **MUL** - умножение. В результате умно­жения двух чисел мы можем получить число, диапазон которого будет в два раза превышать диапазон операндов. Записи выглядят след. образом:
    ```Assembly
    MUL [операнд]    ; где [операнд] регистр или адрес памяти
	```

Некоторые тонкости при умножении:
 1) В 8-разрядной форме операнд может быть любым 8-битным регистром или
адресом памяти. Второй операнд всегда хранится в AL. Результат(произве­
дение) будет записан в регистр АХ.Это означает:
  ```Assembly
	MOV AL, 5
	MOV BH, 5
    MUL BH      ; AX = BH(5) * AL(5)
```

2) В 16-разрядной форме операнд может быть любым 16-битным регистром или
адресом памяти. Второй операнд всегда хранится в АХ . Результат сохраняется
в паре DX:AX.Это означает:
  ```Assembly
	MOV BX, 3
	MOV AX, 6
    MUL BX      ; DX:AX = BX(3) * AX(6) 
```

3) В 32-разрядной форме второй операнд находится в регистре ЕАХ , а результат
записывается в пару EDX:EAX.
  ```Assembly
	MOV EBX, 7
	MOV EAX, 8
    MUL EBX      ; EDX:EAX = EBX(7) * EAX(8) 
```

Другие примеры:
![[Pasted image 20240927014613.png]]

24. Команда **IMUL** умножает целые числа со знаком и может использовать один, два или три операнда. 
Когда указан ___один операнд___, то поведение IMUL бу­дет таким же, как и команды MUL, просто она будет работать с числами сознаком.
Если указано ___два операнда___, то инструкция IMUL умножит первый операнд на второй и сохранит результат в первом операнде, поэтому первый операнд всегда должен быть регистром. Второй операнд может быть регистром, не­ посредственным значением или адресом памяти.
Если указано ___три операнда___, то команда IMUL перемножит второй и третий
операнды, а результат сохранит в первый операнд. Первый операнд только
регистр, второй может быть любого типа, а третий должен быть только непо­средственным значением.
```Assembly
1) В случае с 1 операндом все ясно это MUL.
2)
	MOV EAX,5
	MOV EBX,3
	IMUL EAX,EBX      ;Данные сохраняются в EAX = EAX(5) * EBX(3)
3)
	MOV EBX,8
	IMUL EAX,EBX,      ;Данные сохраняются в EAX = EBX(3) * 8
```

25. Команд DIV - деление.Деление целых чисел — это операция целочисленная, поэтому в результате образуются два значения: частное и остаток.
```Assembly
DIV [операнд]    ; где [операнд] регистр или адрес памяти
```

Некоторые тонкости при делении:
 1)  В 8-битной форме переменный операнд (делитель) может быть любым 8-битным регистром или адресом памяти. Делимое содержится в АХ. Результат сохраняется так: частное — в AL, остаток — в АН.Это означает:
  ```Assembly
	MOV BH,5
	MOV AX,25
	DIV BH 
	;AL = AX(25)/BH(5) = 0x05, AH = 0x00, т.к остаток при делении 25/5 = 0

```

2) В 16-битной форме операнд может быть любым 16-битным регистром или
адресом памяти. Второй операнд всегда находится в паре DX:AX . Результат
сохраняется в паре DX:AX(DX — остаток, А Х — частное).Это означает:
  ```Assembly
	MOV BX, 10
	MOV AX, 35 или MOV DX, 35 
    DIV BX      
    ; DX:AX = AX/DX(35) * BX(10), AX = 0x0003,DX = 0x0005 , т.к остаток при делении 35/10 = 5    
```

3) В 32-разрядной форме делимое находится в паре EDX :EAX , а результат за­
писывается в пару EDX:EAX(частное в ЕАХ,остаток в EDX). (см. пред. пример)

Другие примеры:
![[Pasted image 20240927023210.png]]
![[Pasted image 20240927023222.png]]

>>Команда **IDIV** работает по аналогии с командой IMUL.


## ЛОГИЧЕСКИЕ ОПЕРАНДЫ AND,OR,XOR,NOT


26. Команда **AND** выполняет логическое умножение двух операндов — O1 и O2.
Результат сохраняется в операнде O1. Типы операндов такие же, как у коман­ды ADD: операнды могут быть 8, 16 или 32-битными регистрами, адресами памяти или непосредственными значениями:
```Assembly
AND O1,O2
```

![[Pasted image 20240927023840.png]]

>>  **Небольшое пояснение** для непонятливых: AL = 1 ,BL = 0 ,после лог. умножения получаем, что AL = AL(1) AND BL(0) -> AL = 0x00 , если переводить на человеческий , то это грубо говоря значит что: ___Если хотя бы 1 операнд содержит 0, то и самое выражение будет нулевым.___ То же самое если бы вы записали: 0 * 1 = 0 ;

27. Команда **OR** выполняет логическое сложение двух операндов — O1 и O2.
Результат сохраняется в операнде O1. Типы операндов такие же, как у коман­ды AND: операнды могут быть 8, 16 или 32-битными регистрами, адресами памяти или непосредственными значениями:
```Assembly
OR O1,O2
```

![[Pasted image 20240927024614.png]]

>>  **Небольшое пояснение** для непонятливых: AL = 1 ,BL = 0 ,после лог. сложения получаем, что AL = AL(1) OR BL(0) -> AL = 0x01 , если переводить на человеческий , то это грубо говоря значит что: ___Если хотя бы 1 операнд содержит единицу, то и самое выражение будет единицей.___ То же самое если бы вы записали: 0 + 1 = 1;

28. Команда **XOR** выполняет логическое исключающее сложение двух операндов — O1 и O2. Результат сохраняется в операнде O1. Типы операндов такие же, как у коман­ды AND и OR: операнды могут быть 8, 16 или 32-битными регистрами, адресами памяти или непосредственными значениями:
```Assembly
XOR O1,O2
```

![[Pasted image 20240927024933.png]]
![[Pasted image 20240927025239.png]]

>>  **Небольшое пояснение** для непонятливых: AL = 1 ,BL = 0 ,после лог. ислючающего сложения получаем, что AL = AL(1) XOR BL(0) -> AL = 0x01 , если переводить на человеческий , то это грубо говоря значит что: ___Если  два операнда содержат одинаковые значения, то само выражение становится 0, иначе 1.___ То же самое если бы вы записали: 0 + 0 = 0, 1 + 1 = 0 -> можно сравнить с переполнением регистра или сложением с нулем; 

29. Команда **NOT** выполняет логическое инверсирование отдельных битов.
Результат сохраняется в операнде O1. Типы операндов такие же, как у коман­ды AND,OR,XOR: операнды могут быть 8, 16 или 32-битными регистрами, адресами памяти или непосредственными значениями:
```Assembly
NOT O1
```

![[Pasted image 20240927025446.png]]
![[Pasted image 20240927025702.png]]

 
## Массивы битов (разрядные матрицы)
 
 30. Любое число можно записать в двоичной системе в виде последовательности
нулей и единиц. Например, любое 16-разрядное число состоит из 16 двоичных
цифр — 0 и 1. Мы можем использовать одно число для хранения шестнадцати
различных состояний — **флагов**. Нам не нужно тратить место на хранение 16
различных переменных, ведь для описания состояния (включено/выключено)
вполне достаточно 1 бита. Переменная, используемая для хранения флагов,
называется **разрядной матрицей или массивом битов**.
![[Pasted image 20240929020724.png]]


## ПОСЛЕДОВАТЕЛЬНОЕ ,УСЛОВНОЕ И ЦИКЛИЧЕСКОЕ ВЫПОЛНЕНИЕ ПОДПРОГРАММ


1. 
 ![[Pasted image 20240929021810.png]] 

2. В языках программирования высокого уровня конструкция выбора извест­
на как оператор **IF-THEN**. Эта конструкция позволяет выбрать следующее
действие из нескольких возможных вариантов в зависимости от выполнения
определенного условия. В языке ассемблера механизм выбора реализован
посредством команд сравнения, условного и безусловного переходов. 
![[Pasted image 20240929021952.png]]


## КОМНАДЫ CMP,TEST

3. Команды **СМР** и **TEST** используются для сравнения двух операндов. Операн­
дами могут быть как регистры, так и адреса памяти, размер операнда — 8,
16 или 32 бита:
```Assembly
CMP  O1,O2
TEST O1,O2
```

Команда **СМР** — это сокращение от «compare», «сравнить». Она работает
подобно SUB: операнд о2 вычитается из o1. Результат нигде не сохраняется,
команда просто изменяет регистр признаков. Команда СМР может исполь­
зоваться как **для сравнения целых беззнаковых чисел, так и для сравнения
чисел со знаком.**

Команда **TEST** работает подобно СМР, но вместо вычитания она вычисля­
ет поразрядное И операндов. Результат инструкции — **измененные флаги
регистра признаков.** Мы можем использовать TEST для проверки значений
отдельных битов в массиве битов.


## КОМАНДА JMP

4. Самый простой способ изменить последовательность выполнения команд заключается в использовании команды **JMP** так называемой команда без­ условного перехода. Она перезаписывает указатель команд (регистр IP CS), что заставляет процессор «переключиться» на выполнение команды по указанному адресу.  Формат команды таков: 
   ```Assembly
	JMP [тип_перехода] операнд  
	```

 Команде нужно передать один обяза­тельный операнд — адрес в памяти, с которого процессор должен продолжить выполнение программы. Операнд может быть указан явно (непосредственное значение адреса) или быть регистром общего назначения, в который загружен требуемый адрес. Язык ассемблера, подобно языкам программирования высокого уровня, позволяет обозначить адрес назначения при помощи _метки_.

>> ___Метка___ , о которой говорится в тексте выше ,представляет собой название в конструкции GOTO,например:
>> 
```cpp

BURGER:           //выполнение команды по заданной метке goto

goto BURGER;      //переход к метке


//Пример ,возможно, неудачный поскольку показывает бесконечный цикл...

```

В зависимости от «расстояния» переходы бывают трех типов: **короткие**
(short), **ближние** (near) и **дальние** (far). Тип перехода задается необязательным
параметром инструкции jmp. Если тип не задан, по умолчанию используется
тип near.

Пример:
![[Pasted image 20240929030819.png]]

**Короткий** переход полезен в ситуации, где метка назначения находится в пределах 128 байтов. Поскольку команда **короткого перехода занимает 2 байта**, **команда ближнего перехода занимает 3 байта**, **а дальнего — 5 байтов**, мы можем сэкономить байт или три. Если вы не можете оценить правильное «расстояние», все равно можете по­ пробовать указать short — в крайнем случае, компилятор выдаст ошибку:![[Pasted image 20240929031054.png]]


## КОМНАДЫ УСЛОВНОГО ПЕРЕХОДА J[X]


5.  Условие состоит из значений одного или нескольких флагов в регистре признаков. Работают эти команды одинаково, если условие истинно, выполняется переход на указанную метку, если нет, то процессор продолжит выполнять программу со следующей команды. 
   Общий формат команд условного перехода выгялдит следующим образом:
   ```Assembly
   J[x] метка_назначения
```
   
   Примеры:
   ![[Pasted image 20240930011252.png]]

Любое условие может быть инвертировано, например:
```Assembly 
Jnz is_true     ;переход к метке is_true , если ZF =  0
```

![[Pasted image 20240930011524.png]]
Чтобы лучше запомнить имена команд, запомните
несколько английских слов:
**equal** — равно, 
**above** — больше, 
**below** — ниже,
**zero** — ноль,
**greater** — больше,
**less** — меньше. 
Таким образом, JE — Jump if Equal (Переход, если Равно), JNE — Jump if Not Equal (Переход, если Не Равно), JA — Jump if Above (Переход, если больше) и т.д.

6. Подобно командам MUL и DIV , для работы с числами со знаком служит дру­гой набор команд условного перехода. Причина этого в том, что проверяемое условие состоит из значений других флагов. Адрес назначения команды условного перехода должен лежать в пределах 128 байтов: все они реализуют переходы короткого типа. Если вам нужно «прогуляться» за пределы 128 байтов, то вы должны в инструкции условного перехода указать адрес, по которому будет находиться команда jmp, которая и выполнит дальнейший переход:

```Assembly
jz far_jump                 ;если ZF = 1, перейти к far_jump

...

far_jump:                   ; несколько команд
jmp far finish              ; "дальний" переход

```

Использование инструкции IF-THEN с командой CMP и немного примеров:
![[Pasted image 20240930014215.png]]

Общая схема условного перехода для примера выше:
![[Pasted image 20240930014633.png]]

Улучшение предыдущей программы:
![[Pasted image 20240930020637.png]]


## ЦИКЛЫ


7. **Циклом** называется многократное повторение последователь­ности команд до наступления указанного условия.
8. Мы уже знаем, как ре­ализовать на языке ассемблера конструкции IF и GOTO, из которых можно построить цикл FOR. В качестве счетчика мы будем использовать регистр ЕСХ:
```Assembly

LOOP_START:             ;Заголовок цикла, где инициализуются перменные

	MOV ECX,0           ;Инциализируем регист ECX = 0

LOOP_BODY:              ;Основное тело цикла

	INC ECX             ; ECX = ECX + 1 

	CMP ECX,0x10h       ; Равно ли ECX = 10? если да устанавливаем флаг ZF = 0,                          ; иначе ZF = 1         

	JNZ  LOOP_BODY      ;Если ноль в регистре, то во флаге ZF = 1, то                                    ;прыгаем на метку, иначе если ZF =0 , не прыгаем

LOOP_FINISH:            ;Финишь цикла

	...

```


## КОМАНДА LOOP


10. Общее представление команды выглядит так(напоминает команду MUL):
```Assembly
LOOP [метка]
```
Подобно команде MUL, команда **LOOP** работает с двумя операндами. Первый
операнд фиксирован, и мы не можем его указать явно. Это значение регистра ЕСХ (или С Х). Второй адрес целевой метки цикла. Инструкция LOOP уменьшает значение регистра ЕСХ(СХ) на единицу и, если результат не равен 0, то она переходит на указанную метку. Метка должна быть в пределах 128 байтов (короткий тип перехода).

Пример работы программы с использованием LOOP:
![[Pasted image 20241003031128.png]]

11. Команда **LOOPZ**  позволяет организовать цикл с проверкой дополнительного
условия. Например, мы можем уточнить условие из предыдущего примера:
цикл нужно выполнить, как и раньше, не более 10 раз, но только при условии,
что регистр BХ содержит значение 3(т.е изначально содержит 3 перед запуском цикла). Как только значение в регистре BХ из­менится, цикл нужно прервать.

```Assembly
LOOPZ  [метка]     ;Для целочисленных без знака
LOOPNZ [метка]
LOOPE  [метка]     ;Для целочисленных со  знаком
LOOPNE [метка]
```

Пример:
![[Pasted image 20241003033256.png]]



## СТЕК (STACK)

12. **Очередь или queue** -  это структура данных, при котором работает правило FIFO(First in - Fist out), т.е грубо говоря ,если есть очередь в условном магазине, то выйдет первый тот кто пришел первым.
    
    Общая схема:
    ![[Pasted image 20241003034111.png]]

**НО**!   Существует и другая структура данных, которая использует другое правило LIFO(Last in - First out), т.е это означает , что выходит первый тот , кто последний. По такому принципу и работает наш **Cтек или Stack**.

Общая схема:
![[Pasted image 20241003034625.png]]


13. Вершина стека представлена парой **SS:SP (SS:ESP )** — сегмент стека (Stack Segment) и указатель вершины стека (Stack Pointer). Стек растет в памяти «вниз», то есть новая порция данных записывается по меньшему адресу. Впрочем, точный адрес данных внутри стека не имеет для нас значения, потому что любая операция над стеком имеет дело с его вер­шиной, на которую всегда указывает регистр SP (ESP). Стек может содержать 16- или 32-битные данные. Микропроцессор имеет две команды для работы со стеком — **PUSH и POP**.



## КОМАНДЫ PUSH и POP


14. Команда **PUSH** позволяет поместить в стек содержимое любого 16- или
32-битного регистра или ячейки памяти. Формат команды следующий:
```Assembly

PUSH [ячейка памяти или регистр]   ;Например, PUSH EAX(32 бита)/AX(16 битов)
```

Мы можем сами реализовать команду PUSH с помощью следующей пары
команд:
```Assembly

SUB ESP,4           ;уменьшаем ESP на 4 (ЕАХ — 4 -байтный регистр)
MOV [SS:ESP],EAX    ;сохраняем ЕАХ в стеке

```

>>**Небольшое пояснение для примера выше** для непонятливых: Мы уменьшаем 
>>ESP на 4 для того, чтобы освободить 4 ячейки памяти в стеке, т.к он растет вниз, поэтому освободив 4 ячейки пямяти ,мы можем запулить в пару SS:ESP т.е там где хранятся значения стека как раз такие в эти 4 ячейки, т.к у нас 4 байтный или 32 битный регистр общего назначения , если бы это было 2 байта или 16 битов , то вместо [SUB ESP , 4] мы бы написали [SUB ESP , 2] освободив тем самым 2 ячейки под 2 байта.
>>

Общая схема(если все же непонятно):
![[Pasted image 20241003041240.png]]
Общая схема из книги:
![[Pasted image 20241006060257.png]]

15. Другая команда, **POP**, записывает в свой операнд значение вершины стека
(последнее сохраненное в стеке значение). Тип операнда должен быть таким
же, как у инструкции PUSH (другими словами, если вы поместили в стек
32-разрядный регистр, извлечение из стека должно происходить тоже в 32-
разрядный регистр).

Команду POP можно реализовать с помощью команд MOV и ADD:
```Assembly

MOV EAX,[SS:ESP]      ;помещаем указатель на регистр(т.е на его вершину)


ADD ESP,4             ;т.к стек растет вниз(мы использовали SUB для выделения                          ;памяти), если он будет расти вверх(команда сложения ADD),                       ;то это будет означать, что стек удаляет выделенную память                       ;под регистр
```


Пример:
![[Pasted image 20241003042100.png]]

В результате выполнения этих команд мы поменяем местами значение реги­стров 
ЕАХ и ESI: сначала помещаем в стек значение ЕАХ , затем — ESI, после
этого извлекаем из стека последнее сохраненное значение (бывшее значение
регистра ESI) в регистр ЕАХ , после этого в стеке останется бывшее значение
ЕАХ , которое мы записываем в ESI.



## КОМАНДЫ PUSHA,POPA ,PUSHAD,POPAD  
## [РАБОТАЕТ ТОЛЬКО НА 32 и 16 РАЗРЯДНЫХ АРХИТЕКТУРАХ !!!!]

16. Иногда полезно сохранить в стеке значения сразу всех регистров общего на­
значения. Для этого используется команда **PUSHА**, а для извлечения из стека
значений всех регистров служит команда **РОРА**(попа). Команды PUSHA и РОРА
помещают в стек и извлекают из него все 16-разрядные регистры. Операндов
у этих команд нет(сохраняют только 16-разрядные регистры,но не 32 разрядные).

17. Для сохранения и восстановле­ния значений расширенных регистров служат команды **PUSHAD и POPAD**(сохраняют 32 разрядные и 16 разрядные регистры).

18. Регистры помещаются в стек в следующем порядке (сверху вниз):
			(Е)АХ, (Е)СХ, (Е)D X , (Е)ВХ, (E)SP, (Е)ВР, (E)SI, (E)DI 




## КОМАНДЫ PUSHF,POPF 

19. Рассмотренные четыре команды не заботились о помещении в стек регистра
признаков. В 16-битных процессорах и регистр признаков был 16-битным, по­
этому для помещения в стек флагов и восстановления из него использовались
команды **PUSHF и POPF.** 

Пример работы:
![[Pasted image 20241006062226.png]]

>>  **Для непоняливых**: Когда мы PUSH'им регистры флагов в стек, т.е их состояние ,грубо говоря,то мы сохраняем это состояние во время PUSH'а. Мы можем изменять флаги в стеке и это норма, но после того как мы применим команду POP, то соответсвенно мы вернемся к тому состоянию когда их сохраняли в стек.


## КОМАНДЫ CALL , RET

20. Для вызова подпрограммы(функции) используется команда **CALL**, а для возврата из подпрограммы в основную программу — **RET** .Формат обеих команд таков:
```Assembly
CALL [тип вызова] [операнды]

RET
```

21. Команде CALL нужно передать всего один операнд — адрес начала подпро­граммы. Это может быть непосредственное значение, содержимое регистра, памяти или метка. В отличие от JMP, при выполнении команды CALL первым делом сохраняется в стеке значение регистра IP (EIP). Передача управления на указанный адрес называется **вызовом подпрограммы**. Как и команде JMP, команде CALL можно указать «размер шага». По умол­чанию используется near. Когда происходит вызов типа far, сегментный регистр CS также сохраняется в стеке вместе с IP (EIP).

22. Как и команде JMP, команде CALL можно указать «размер шага». По умол­чанию используется near. Когда происходит вызов типа far , сегментный регистр CS также сохраняется в стеке вместе с IP (EIP). Возврат из подпрограммы выполняется с помощью команды RET,которая выталкивает из стека его вершину в IP (EIP). После этого процессор про­должит выполнение инструкций, находящихся в основной программе после команды CALL. 

Если подпрограмма вызывалась по команде CALL far, то для возврата из
нее нужно восстановить не только IP (EIP), но и CS: следует использовать
команду **RETF** , а не RET .

23. Пример:
    ![[Pasted image 20241007020937.png]]

>> **Пару слов о том, как объявить функцию в Assembly под NASM(возможно и под другими компиляторами)**: Итак, чтобы объявитьб функцию в NASM необходимо в секции .text (section .text или segment .text) , объявить функцию до точки входа (global start). Примером может служить С++ или Си, где функции объявляются до точки входа.Пример:
>>![[Pasted image 20241007021347.png]]



## КОМАНДЫ INT, IRET


24. Программные прерывания порождаются по ко­манде **INT**. Программные прерывания можно рассматривать как «прерывания по требованию», например, когда вы вызываете подпрограмму операционной системы для вывода строки символов. В случае с программным прерыванием вы сами определяете, какое прерывание будет вызвано в тот или иной момент. Команде INT нужно передать всего один 8 -битный операнд, который задает номер нужного прерывания.
```Assembly
INT OP
```

25. ![[Pasted image 20241007033158.png]] 
26. Теперь процессор будет выполнять другую программу обработчик пре­рывания. Адрес этой программы называется **вектором прерывания**. Векторы прерывания хранятся в таблице векторов прерываний, находящейся в памяти. Таблицу прерываний можно представить себе как массив адресов подпро­грамм, в котором индекс массива соответствует номеру прерывания. После того, как процессор определит адрес обработчика прерывания, он за­пишет его в пару CS и (Е)IР. Следующая выполненная команда будет первой командой обработчика прерывания.


27. Возврат из обработчика прерывания осуществляется с помощью команды
**IRET** , которая восстанавливает исходные значения (E)IP , CS и флагов из
стека. Формат команды: 
```Assembly
IRET
```

28. 
![[Pasted image 20241007033720.png]]

Прежде всего процессор находит номер прерывания. Программные преры­вания вызываются инструкцией INT, которая содержит номер прерывания в своем операнде. Следующий шаг сохранение контекста программы в стеке.

```Assembly

;Пример того как реализован INT, но его можно реализовать и самому

PUSHF 

PUSH CS

;Чтобы сохранить IP в стеке нужно вызывать подпрограмму(фукнцию), такие махинации делаются , поскольку мы не можем сохранить указатель на инструкцию PUSH (E)IP.Но если мы вызовем функуцию ниже , то компилятор за нас сохранит этот указатель.(смотри описание команды CALL в этой же доке)

ip_save_stack:

CALL ip_save_stack

```

Последний шаг — это безусловный переход на адрес, прочитанный из таблицы
прерываний по номеру запрошенного прерывания: JMP far.
Таблица векто­ров прерываний находится в самом начале адресуемой памяти, то есть по адресу 0x0000:0x0000. Каждый из векторов прерывания занимает четыре байта. Первые два байта определяют новое значение IP (то есть смещение), а оставшиеся два — новое значение сегментного регистра CS. Вектор пре­рывания номер 0x21 хранится по адресу 0x0000: (0x21 * 4), поэтому его вызов можно записать так:

```Assembly
jmp far [0x21*4]
```

![[Pasted image 20241007042902.png]]



# ПРОЧИЕ КОМАНДЫ
## КОМАНДЫ CLI,STI ИЗМЕНЕНИЯ ФЛАГОВ (IF и ID)[ПРИ ВЫЗОВЕ ВЫДАЮТ ОШИБКУ]


1. Команды **CLI** (Clear Interrupt) и **STI** (Set Interrupt) сбрасывают и устанав­ливают флаг прерывания **IF** . Иными словами, при их помощи вы можете за­претить или разрешить аппаратные прерывания. Если этот флаг установлен (1), аппаратные прерывания разрешены. Команда CLI сбрасывает флаг (0) запрещает аппаратные прерывания. Потом вы должны снова разрешить их, выполнив команду STI.
```Assembly
CLI  ;Выключаем прерывания,и сбрасываем флаг IF = 0

STI  ;Включаем прерывания, и устанавливаем флаг IF = 1
```



## КОМАНДЫ CLD,STD[ПРИ ВЫЗОВЕ ВЫДАЮТ ОШИБКУ]


2. **Команды STD и CLD** модифицируют значение флага **DF**. Этим флагом поль­зуется группа команд для обработки строк. Команда CLD сбрасывает этот флаг (что означает отсчет вверх), a STD устанавливает его (отсчет в обратном порядке).
```Assembly
CLD  ;Сбрасывает флаг DF = 0

STD  ;Устанавливает флаг DF  = 1
```



## КОМАНДА XCHG

3. Очень часто нам нужно поменять местами значения двух регистров. Конечно,
можно это сделать, используя третии, временный, регистр, но намного проще
использовать инструкцию **XCHG** (exchange — обмен), которая как раз для
этого и предназначена.

Подобно инструкции MOV, она имеет два операнда — O1 и O2 . Каждый из
них может быть 8 -, 16- и 32-разрядным, и только один из них может находиться
в памяти — требования такие же, как у команды MOV.

```Assembly

;Меняет местами 2 операнда

XCHG EAX,EBX

;то же самое , что и 

MOV ECX,EAX

MOV EAX,EBX

MOV EBX,ECX

```

Примеры:
![[Pasted image 20241009044656.png]]



## КОМАНДА LEA


4. Имя этой команды — это сокращение от **«Load Effective Address»**, то есть
«загрузить эффективный адрес». Она вычисляет эффективный адрес второго
операнда и сохраняет его в первом операнде (который может быть только
регистром). Синтаксис этой команды требует, чтобы второй операнд был за­
ключен в квадратные скобки, но фактически она не адресует память.

```Assembly
LEA EAX, [EBX]
```

LEA полезна в тех случаях, когда мы не собираемся обращаться к памяти, а
адрес нужен нам для другой цели:

```Assembly
LEA EAX, [EBX*4+ECX]
```

Значение, вычисленное командой LEA , не обязательно рассматривать как
адрес: ее можно использовать для целочисленных арифметических вычисле-
ний. 

## КОМАНДЫ STOS[x] (запись строки в память)

>>Порядок отсчета байтов в строке во время работы этих команд зависит от флага направления (**DF**).


5. Под единым обозначением **STOSx (STOre String)** скрываются три команды:
```Assembly

 STOSB   
    
 STOSW
 
 STOSD
```

Команда **STOSB** копирует содержимое регистра AL в ячейку памяти, адрес
которой находится в паре регистров ES:(E)DI, и уменьшает или увеличивает
(в зависимости от флага DF) на единицу значение регистра (E)DI, чтобы при­
готовиться к копированию AL в следующую ячейку. Если DF=0, то (E)DI
будет увеличен на 1, в противном случае уменьшен на 1. Какой регистр будет использоваться — DI или EDI — зависит от режима процессора.

Вторая инструкция, **STOSW** , работает аналогично, но данные берутся из
регистра АХ , a (E)DI уменьшается/увеличивается на 2. 

**STOSD** копирует со­держимое ЕАХ , a E(DI) уменьшает/увеличивает на 4.

